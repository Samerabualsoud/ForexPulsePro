"""
Manus AI Integration for Advanced Market Analysis
Replaces ChatGPT with Manus AI for trading signal analysis and insights
"""

import os
import requests
import logging
from typing import Dict, List, Optional, Any
import json

logger = logging.getLogger(__name__)

class ManusAI:
    """Manus AI service for advanced market analysis"""
    
    def __init__(self):
        self.name = "Manus AI"
        self.api_key = os.getenv('MANUS_API')
        
        # Manus AI API endpoints (adjust based on actual API documentation)
        self.base_url = "https://api.manus.ai/v1"  # Placeholder - update with actual endpoint
        
        logger.info(f"Manus AI service initialized")
        
    def is_available(self) -> bool:
        """Check if Manus AI service is available"""
        return bool(self.api_key)
    
    def _make_request(self, endpoint: str, data: Dict = None) -> requests.Response:
        """Make request to Manus AI API"""
        url = f"{self.base_url}{endpoint}"
        
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }
        
        try:
            if data:
                response = requests.post(url, headers=headers, json=data, timeout=30)
            else:
                response = requests.get(url, headers=headers, timeout=30)
                
            response.raise_for_status()
            return response
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Manus AI API request failed: {e}")
            raise
    
    def analyze_market_conditions(self, market_data: Dict) -> Dict:
        """Analyze current market conditions using Manus AI"""
        if not self.is_available():
            return self._fallback_analysis(market_data)
            
        try:
            analysis_prompt = {
                "task": "market_analysis",
                "data": market_data,
                "requirements": [
                    "Market trend analysis",
                    "Volatility assessment", 
                    "Risk factors",
                    "Trading opportunities",
                    "Key support/resistance levels"
                ]
            }
            
            # Note: Adjust endpoint based on actual Manus AI API
            response = self._make_request("/analyze", analysis_prompt)
            result = response.json()
            
            logger.info("Market analysis completed by Manus AI")
            return result
            
        except Exception as e:
            logger.error(f"Manus AI market analysis failed: {e}")
            return self._fallback_analysis(market_data)
    
    def generate_signal_insights(self, signal_data: Dict) -> Dict:
        """Generate insights for trading signals using Manus AI"""
        if not self.is_available():
            return self._fallback_signal_insights(signal_data)
            
        try:
            insight_prompt = {
                "task": "signal_analysis",
                "signal": signal_data,
                "analysis_type": [
                    "Signal strength assessment",
                    "Risk-reward analysis",
                    "Entry/exit optimization",
                    "Market context evaluation"
                ]
            }
            
            response = self._make_request("/signals/analyze", insight_prompt)
            result = response.json()
            
            logger.info("Signal insights generated by Manus AI")
            return result
            
        except Exception as e:
            logger.error(f"Manus AI signal analysis failed: {e}")
            return self._fallback_signal_insights(signal_data)
    
    def generate_portfolio_recommendations(self, portfolio_data: Dict) -> Dict:
        """Generate portfolio optimization recommendations"""
        if not self.is_available():
            return self._fallback_portfolio_recommendations(portfolio_data)
            
        try:
            portfolio_prompt = {
                "task": "portfolio_optimization",
                "portfolio": portfolio_data,
                "objectives": [
                    "Risk optimization",
                    "Diversification analysis",
                    "Performance enhancement",
                    "Correlation analysis"
                ]
            }
            
            response = self._make_request("/portfolio/optimize", portfolio_prompt)
            result = response.json()
            
            logger.info("Portfolio recommendations generated by Manus AI")
            return result
            
        except Exception as e:
            logger.error(f"Manus AI portfolio analysis failed: {e}")
            return self._fallback_portfolio_recommendations(portfolio_data)
    
    def _fallback_analysis(self, market_data: Dict) -> Dict:
        """Fallback analysis when Manus AI is unavailable"""
        return {
            "status": "fallback",
            "analysis": {
                "trend": "Analyzing using traditional methods",
                "volatility": "Standard volatility calculations applied",
                "recommendations": "Basic technical analysis completed",
                "note": "Manus AI unavailable - using fallback analysis"
            }
        }
    
    def _fallback_signal_insights(self, signal_data: Dict) -> Dict:
        """Fallback signal insights when Manus AI is unavailable"""
        return {
            "status": "fallback", 
            "insights": {
                "strength": "Calculated using traditional indicators",
                "risk_reward": "Standard risk management applied",
                "recommendation": "Follow standard signal guidelines",
                "note": "Manus AI unavailable - using fallback insights"
            }
        }
    
    def _fallback_portfolio_recommendations(self, portfolio_data: Dict) -> Dict:
        """Fallback portfolio recommendations when Manus AI is unavailable"""
        return {
            "status": "fallback",
            "recommendations": {
                "diversification": "Standard diversification rules applied",
                "risk_management": "Traditional risk management in use",
                "optimization": "Basic portfolio optimization applied",
                "note": "Manus AI unavailable - using fallback recommendations"
            }
        }
    
    def optimize_strategy_portfolio(self, strategy_data: Dict) -> Dict:
        """Optimize strategy portfolio allocation using Manus AI analysis"""
        if not self.is_available():
            return self._fallback_strategy_optimization(strategy_data)
            
        try:
            optimization_prompt = {
                "task": "strategy_portfolio_optimization",
                "strategies": strategy_data,
                "optimization_goals": [
                    "Risk-adjusted returns maximization",
                    "Drawdown minimization",
                    "Correlation analysis",
                    "Market regime adaptation",
                    "Capital allocation efficiency"
                ],
                "constraints": {
                    "max_allocation_per_strategy": 0.4,
                    "min_strategies_active": 3,
                    "risk_tolerance": "moderate"
                }
            }
            
            response = self._make_request("/portfolio/optimize_strategies", optimization_prompt)
            result = response.json()
            
            logger.info("Strategy portfolio optimization completed by Manus AI")
            return result
            
        except Exception as e:
            logger.error(f"Manus AI strategy optimization failed: {e}")
            return self._fallback_strategy_optimization(strategy_data)
    
    def design_optimal_table(self, table_context: Dict) -> Dict:
        """Generate optimal table design recommendations using Manus AI"""
        if not self.is_available():
            return self._fallback_table_design(table_context)
            
        try:
            design_prompt = {
                "task": "trading_table_optimization",
                "context": table_context,
                "design_principles": [
                    "Information hierarchy optimization",
                    "Cognitive load reduction",
                    "Trading workflow efficiency",
                    "Visual clarity enhancement",
                    "Mobile responsiveness"
                ],
                "requirements": {
                    "data_density": "high",
                    "user_type": "professional_trader",
                    "primary_actions": ["signal_analysis", "risk_assessment", "trade_execution"]
                }
            }
            
            response = self._make_request("/design/optimize_table", design_prompt)
            result = response.json()
            
            logger.info("Table design optimization completed by Manus AI")
            return result
            
        except Exception as e:
            logger.error(f"Manus AI table design failed: {e}")
            return self._fallback_table_design(table_context)
    
    def _fallback_strategy_optimization(self, strategy_data: Dict) -> Dict:
        """Fallback strategy optimization when Manus AI is unavailable"""
        # Calculate basic optimization based on Sharpe ratio and drawdown
        strategies = strategy_data.get('strategies', {})
        total_strategies = len(strategies)
        
        # Simple equal-weight fallback with performance bias
        optimized_allocations = {}
        performance_scores = {}
        
        for strategy_name, metrics in strategies.items():
            # Calculate performance score (Sharpe ratio weighted by win rate)
            sharpe = metrics.get('sharpe_ratio', 0)
            win_rate = metrics.get('win_rate', 0.5)
            max_dd = metrics.get('max_drawdown', 0.2)
            
            # Performance score: emphasize positive Sharpe, high win rate, low drawdown
            score = (sharpe * 0.4) + (win_rate * 0.4) - (max_dd * 0.2)
            performance_scores[strategy_name] = max(score, 0.1)  # Minimum allocation
        
        # Normalize scores to allocations
        total_score = sum(performance_scores.values())
        for strategy_name in strategies:
            allocation = performance_scores[strategy_name] / total_score
            # Cap maximum allocation at 40%
            optimized_allocations[strategy_name] = min(allocation, 0.4)
        
        # Renormalize if capping occurred
        total_allocation = sum(optimized_allocations.values())
        if total_allocation != 1.0:
            for strategy in optimized_allocations:
                optimized_allocations[strategy] /= total_allocation
        
        return {
            "status": "fallback",
            "optimization": {
                "recommended_allocations": optimized_allocations,
                "reasoning": "Performance-weighted allocation based on Sharpe ratio and win rate",
                "risk_level": "moderate",
                "expected_sharpe": sum(strategies[s]['sharpe_ratio'] * optimized_allocations[s] for s in strategies),
                "diversification_score": 0.7,
                "note": "Manus AI unavailable - using traditional optimization"
            }
        }
    
    def _fallback_table_design(self, table_context: Dict) -> Dict:
        """Fallback table design when Manus AI is unavailable"""
        data_type = table_context.get('data_type', 'general')
        
        if data_type == 'strategy_performance':
            recommendations = {
                "column_order": [
                    "strategy_name", "win_rate", "total_trades", "avg_pnl", 
                    "profit_factor", "sharpe_ratio", "max_drawdown", "status"
                ],
                "formatting": {
                    "win_rate": "percentage_green_red",
                    "avg_pnl": "currency_color_coded", 
                    "profit_factor": "decimal_2_color_coded",
                    "sharpe_ratio": "decimal_2_color_coded",
                    "max_drawdown": "percentage_red_emphasis"
                },
                "sorting": {
                    "default": "profit_factor",
                    "direction": "descending"
                },
                "visual_cues": {
                    "top_performer": "green_highlight",
                    "underperformer": "yellow_background",
                    "risk_warning": "red_border"
                }
            }
        else:
            # Generic table recommendations
            recommendations = {
                "column_order": ["name", "value", "change", "status"],
                "formatting": {
                    "value": "auto_format",
                    "change": "color_coded_change"
                },
                "sorting": {
                    "default": "value",
                    "direction": "descending"
                }
            }
        
        return {
            "status": "fallback",
            "design": {
                "layout": recommendations,
                "best_practices": [
                    "Use consistent color coding for performance metrics",
                    "Prioritize most actionable data in leftmost columns",
                    "Apply visual hierarchy with typography and spacing",
                    "Include hover states for detailed information"
                ],
                "accessibility": {
                    "contrast_ratio": "4.5:1 minimum",
                    "keyboard_navigation": "full_support",
                    "screen_reader": "aria_labels_required"
                },
                "note": "Manus AI unavailable - using standard design principles"
            }
        }

    def test_connection(self) -> bool:
        """Test connection to Manus AI"""
        if not self.is_available():
            return False
            
        try:
            # Test with a simple health check (adjust endpoint as needed)
            response = self._make_request("/health")
            return response.status_code == 200
        except:
            return False